open Bwd
open Util
open Tbwd
open Dim
open Core
open Syntax
open Term
open Reporter
module StringMap = Map.Make (String)

let __DEFAULT_NAME__ = "H"

(* Track the used variable names, to generate fresh ones for bound variables if needed. *)

(* We store a parametrized list like a context, and also a map that counts how many like-named variables already exist, so that we can create a new one with an unused number. *)
type 'b ctx = Emp : emp ctx | Snoc : 'b ctx * 'n variables -> ('b, 'n) snoc ctx
type 'b t = { ctx : 'b ctx; used : int StringMap.t }

let empty : emp t = { ctx = Emp; used = StringMap.empty }

let cubevar x fa : string list =
  let fa = string_of_sface fa in
  if fa = "" then [ x ] else [ x; fa ]

(* Look up an index variable to find a name for it. *)
let lookup : type n. n t -> n index -> string list =
 fun { ctx; used = _ } x ->
  let rec lookup : type n. n ctx -> n index -> string list =
   fun ctx x ->
    match (ctx, x) with
    | Emp, _ -> .
    | Snoc (ctx, _), Pop x -> lookup ctx x
    | Snoc (_, Variables (_, mn, xs)), Top fa -> (
        let (SFace_of_plus (_, fb, fc)) = sface_of_plus mn fa in
        match NICubeOf.find xs fc with
        | Some x -> cubevar x fb
        | None -> fatal (Anomaly "reference to anonymous variable")) in
  lookup ctx x

(* Make a variable name unique, adding the new one to the list of used variables and returning it. *)
let uniquify : string -> int StringMap.t -> string * [ `Original | `Renamed ] * int StringMap.t =
 fun name used ->
  match StringMap.find_opt name used with
  | None -> (name, `Original, used |> StringMap.add name 0)
  | Some n ->
      (* The tentative new name is the original one suffixed by that number.  But the user might already have created a variable with that name, so we have to increment the number until we find an unused name.  *)
      let rec until_unique k =
        let namek = name ^ string_of_int k in
        match StringMap.find_opt namek used with
        | None -> (namek, k)
        | Some _ -> until_unique (k + 1) in
      let namen, n = until_unique n in
      (namen, `Renamed, used |> StringMap.add namen 0 |> StringMap.add name (n + 1))

let uniquify_opt :
    string option -> int StringMap.t -> string option * [ `Original | `Renamed ] * int StringMap.t =
 fun name used ->
  match name with
  | None -> (None, `Original, used)
  | Some name ->
      let name, orig, used = uniquify name used in
      (Some name, orig, used)

(* Do the same thing to a whole cube of variable names. *)
let uniquify_cube :
    type n left right.
    (left, n, string option, right) NICubeOf.t ->
    int StringMap.t ->
    (left, n, string option, right) NICubeOf.t * int StringMap.t =
 fun names used ->
  (* Apparently we need to define the iteration function with an explicit type so that it ends up sufficiently polymorphic. *)
  let uniquify_nfamof :
      type m left right.
      (left, m, string option, right) NFamOf.t ->
      int StringMap.t ->
      (left, m, string option, right) NFamOf.t * int StringMap.t =
   fun (NFamOf name) used ->
    let name, _, used = uniquify_opt name used in
    (NFamOf name, used) in
  let open NICubeOf.Applicatic (Applicative.OfMonad (Monad.State (struct
    type t = int StringMap.t
  end))) in
  mapM { map = (fun _ name used -> uniquify_nfamof name used) } names used

(* Add a new variable, generating a fresh version of its name if necessary to avoid conflicts. *)
let add_cube : type n b. n D.t -> b t -> string option -> string option * (b, n) snoc t =
 fun n { ctx; used } name ->
  let name, _, used = uniquify_opt name used in
  (name, { ctx = Snoc (ctx, Variables (n, D.plus_zero n, NICubeOf.singleton name)); used })

(* Same, but starting from an unnamed variable and giving it a default name. *)
let add_cube_autogen : type n b. n D.t -> b t -> string * (b, n) snoc t =
 fun n ctx ->
  let x, used = add_cube n ctx (Some __DEFAULT_NAME__) in
  (Option.get x, used)

let add : 'b t -> 'n variables -> 'n variables * ('b, 'n) snoc t =
 fun { ctx; used } (Variables (m, mn, names)) ->
  let names, used = uniquify_cube names used in
  let vars = Variables (m, mn, names) in
  (vars, { ctx = Snoc (ctx, vars); used })

(* Extract all the names in a context. *)
let rec of_ordered_ctx : type a b. (a, b) Ctx.Ordered.t -> b t = function
  | Emp -> empty
  | Snoc (ctx, Vis (m, mn, name, _), _) -> snd (add (of_ordered_ctx ctx) (Variables (m, mn, name)))
  | Snoc (ctx, Invis xs, Zero) -> snd (add_cube (CubeOf.dim xs) (of_ordered_ctx ctx) None)
  | Lock ctx -> of_ordered_ctx ctx

let of_ctx : type a b. (a, b) Ctx.t -> b t = function
  | Permute (_, ctx) -> of_ordered_ctx ctx

let unsafe_add : 'b t -> 'n variables -> ('b, 'n) snoc t =
 fun { ctx; used } vars -> { ctx = Snoc (ctx, vars); used }

(* Uniquify the names in a varscope from the *right*, thus leaving unchanged those that are still in lexical scope.  Also assigns an autogenerated name to previously unnamed variables.  Returns a Names object in the empty context that can then be used to build up a new one including those variables.  Since those variables have already been uniquified, they should be added in with unsafe_add.  (TODO: Can we avoid having to expose unsafe_add?) *)
let rec used_vars :
    type n.
    (string option * (string * Field.t) Bwd.t, n) Bwv.t ->
    int StringMap.t ->
    ( string * [ `Visible | `Shadowed ] * (string * [ `Visible | `Shadowed ] * Field.t) Bwd.t,
      n )
    Bwv.t
    * int StringMap.t =
 fun vars used ->
  let do_var x used =
    match x with
    | Some x ->
        if StringMap.mem x used then (x, `Shadowed, used)
        else (x, `Visible, used |> StringMap.add x 0)
    | None -> (__DEFAULT_NAME__, `Shadowed, used) in
  match vars with
  | Emp -> (Emp, used)
  | Snoc (vars, (x, flds)) ->
      let used, flds =
        Bwd.fold_right_map
          (fun (x, f) used ->
            let x, o, used = do_var (Some x) used in
            (used, (x, o, f)))
          flds used in
      let x, o, used = do_var x used in
      let vars, used = used_vars vars used in
      (Snoc (vars, (x, o, flds)), used)

let uniquify_varscope :
    type a.
    a Varscope.t ->
    ( string * [ `Original | `Renamed ] * (string * [ `Original | `Renamed ] * Field.t) Bwd.t,
      a )
    Bwv.t
    * emp t =
 fun vars ->
  let vars, used = used_vars vars StringMap.empty in
  let rec go :
      type n.
      ( string * [ `Visible | `Shadowed ] * (string * [ `Visible | `Shadowed ] * Field.t) Bwd.t,
        n )
      Bwv.t ->
      int StringMap.t ->
      ( string * [ `Original | `Renamed ] * (string * [ `Original | `Renamed ] * Field.t) Bwd.t,
        n )
      Bwv.t
      * int StringMap.t =
   fun vars used ->
    match vars with
    | Emp -> (Emp, used)
    | Snoc (vars, (x, sh, flds)) ->
        let used, flds =
          Bwd.fold_right_map
            (fun (name, sh, fld) used ->
              match sh with
              | `Visible -> (used, (name, `Original, fld))
              | `Shadowed ->
                  let name, _, used = uniquify name used in
                  (used, (name, `Renamed, fld)))
            flds used in
        let x, orig, used =
          match sh with
          | `Visible -> (x, `Original, used)
          | `Shadowed ->
              let x, _, used = uniquify x used in
              (x, `Renamed, used) in
        let vars, used = go vars used in
        (Snoc (vars, (x, orig, flds)), used) in
  let vars, used = go vars used in
  (vars, { ctx = Emp; used })
