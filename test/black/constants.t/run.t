  $ narya -v constants.ny
   ￫ info[I0000]
   ￮ constant CN defined
  
   ￫ info[I0000]
   ￮ constant zero defined
  
   ￫ info[I0000]
   ￮ constant one defined
  
   ￫ info[I0000]
   ￮ constant two defined
  
   ￫ info[I0000]
   ￮ constant three defined
  
   ￫ info[I0000]
   ￮ constant four defined
  
   ￫ info[I0000]
   ￮ constant one_eq defined
  
   ￫ info[I0000]
   ￮ constant cplus defined
  
   ￫ info[I0000]
   ￮ constant cplus_one_one_eq_two defined
  
   ￫ info[I0000]
   ￮ constant ctimes defined
  
   ￫ info[I0000]
   ￮ constant ctimes_two_two_eq_four defined
  
   ￫ info[I0000]
   ￮ constant Σ defined
  
   ￫ info[I0000]
   ￮ constant zero_zero defined
  
   ￫ info[I0000]
   ￮ constant zero_zero_fst_eq_zero defined
  
   ￫ info[I0000]
   ￮ constant zero_zero_snd_eq_zero defined
  
   ￫ info[I0001]
   ￮ axiom A assumed
  
   ￫ info[I0001]
   ￮ axiom B assumed
  
   ￫ info[I0001]
   ￮ axiom a assumed
  
   ￫ info[I0001]
   ￮ axiom b assumed
  
   ￫ info[I0000]
   ￮ constant ab defined
  
   ￫ info[I0000]
   ￮ constant ab_fst_eq_a defined
  
   ￫ info[I0000]
   ￮ constant ab_snd_eq_b defined
  
   ￫ info[I0000]
   ￮ constant ab_fst_eq_a' defined
  
   ￫ info[I0000]
   ￮ constant ab_snd_eq_b' defined
  
   ￫ info[I0000]
   ￮ constant zero_zero' defined
  
   ￫ info[I0000]
   ￮ constant zero_zero_eq_zero_zero' defined
  
   ￫ info[I0000]
   ￮ constant built_in_pi_eqs_named_pi defined
  
   ￫ info[I0000]
   ￮ constant refl_for_pi defined
  
   ￫ info[I0000]
   ￮ constant Stream defined
  
   ￫ info[I0000]
   ￮ constant zeros defined
  
   ￫ info[I0000]
   ￮ constant zeros_first_term_eq_zero defined
  
   ￫ info[I0000]
   ￮ constant zeros_second_term_eq_zero defined
  
   ￫ info[I0000]
   ￮ constant zeros_third_term_eq_zero defined
  
   ￫ info[I0000]
   ￮ constant zeros_fourth_term_eq_zero defined
  
   ￫ info[I0000]
   ￮ constant nats defined
  
   ￫ info[I0000]
   ￮ constant nats_zero_third_term_eq_two defined
  
   ￫ info[I0000]
   ￮ constant nats_zero_fifth_term_eq_four defined
  
   ￫ info[I0000]
   ￮ constant ∞eta defined
  
   ￫ info[I0000]
   ￮ constant ∞eta_bisim defined
  
   ￫ info[I0000]
   ￮ constant ℕ defined
  
   ￫ info[I0000]
   ￮ constant Nat defined
  
   ￫ info[I0000]
   ￮ constant plus defined
  
   ￫ info[I0000]
   ￮ constant times defined
  
   ￫ info[I0000]
   ￮ constant List defined
  
   ￫ info[I0000]
   ￮ constant append defined
  
   ￫ info[I0000]
   ￮ constant append_eq_sample defined
  
   ￫ info[I0000]
   ￮ constant Vec defined
  
   ￫ info[I0000]
   ￮ constant lplus defined
  
   ￫ info[I0000]
   ￮ constant vappend defined
  
   ￫ info[I0000]
   ￮ constant vappend_eq_sample defined
  
   ￫ info[I0000]
   ￮ constant exp defined
  
   ￫ info[I0000]
   ￮ constant exp_eq_sample defined
  
   ￫ info[I0000]
   ￮ constant exp2 defined
  
   ￫ info[I0000]
   ￮ constant exp_eq_sample' defined
  
   ￫ info[I0000]
   ￮ constant ∅ defined
  
   ￫ info[I0000]
   ￮ constant abort1 defined
  
   ￫ info[I0000]
   ￮ constant abort2 defined
  
   ￫ info[I0001]
   ￮ axiom f assumed
  
   ￫ info[I0000]
   ￮ constant reflf defined
  
   ￫ info[I0000]
   ￮ constant reflf_eq_reflf defined
  
   ￫ info[I0000]
   ￮ constant refl_abort_f defined
  
   ￫ info[I0000]
   ￮ constant refl_nat_f defined
  
   ￫ info[I0000]
   ￮ constant refl_nat_f_eq_reflf defined
  
   ￫ info[I0000]
   ￮ constant refl_abort_f_cube defined
  
   ￫ info[I0000]
   ￮ constant refl_nat_f_cube defined
  
   ￫ info[I0000]
   ￮ constant evaluated_eq_sample defined
  
   ￫ info[I0000]
   ￮ constant foo defined
  
   ￫ info[I0000]
   ￮ constant bar defined
  
   ￫ info[I0000]
   ￮ constant bar_eq_sample defined
  
   ￫ info[I0000]
   ￮ constant bar_eq_sample' defined
  
   ￫ info[I0000]
   ￮ constant prec defined
  
   ￫ info[I0000]
   ￮ constant idnat defined
  
   ￫ info[I0000]
   ￮ constant apprec defined
  
   ￫ info[I0000]
   ￮ constant ⊤ defined
  
   ￫ info[I0000]
   ￮ constant code defined
  
   ￫ info[I0000]
   ￮ constant rcode defined
  
   ￫ info[I0000]
   ￮ constant encode defined
  
   ￫ info[I0000]
   ￮ constant decode defined
  
   ￫ info[I0000]
   ￮ constant encode_decode defined
  
   ￫ info[I0000]
   ￮ constant decode_encode defined
  
   ￫ info[I0000]
   ￮ constant mtchbd0 defined
  
   ￫ info[I0000]
   ￮ constant mtchbd0' defined
  
   ￫ info[I0000]
   ￮ constant mtchbd0'' defined
  
   ￫ info[I0000]
   ￮ constant mtchtup defined
  
   ￫ info[I0000]
   ￮ constant mtchtup2 defined
  
   ￫ info[I0000]
   ￮ constant Covec defined
  
   ￫ info[I0000]
   ￮ constant nil defined
  
   ￫ info[I0000]
   ￮ constant onetwo defined
  
   ￫ info[I0000]
   ￮ constant covec_eq_sample defined
  
   ￫ info[I0000]
   ￮ constant covec_eq_sample' defined
  
   ￫ info[I0000]
   ￮ constant covec_eq_sample'' defined
  
   ￫ info[I0000]
   ￮ constant coconcat defined
  
  $ narya constants.ny -e "def one_eq_zero : Id CN one zero := refl one" 
   ￫ error[E0401]
   ￭ command-line exec string
   1 | def one_eq_zero : Id CN one zero := refl one
     ^ term synthesized type
         {A₀ : Type} {A₁ : Type} (A₂ : refl Type A₀ A₁) {H₀ : A₀ → A₀} {H₁ : A₁ → A₁}
         (H₂ : {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′) →⁽ᵉ⁾ A₂ (H₀ H₀′) (H₁ H₁′))
         {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′)
         →⁽ᵉ⁾ A₂ (H₀ H₀′) (H₁ H₁′)
       but is being checked against type
         {A₀ : Type} {A₁ : Type} (A₂ : refl Type A₀ A₁) {H₀ : A₀ → A₀} {H₁ : A₁ → A₁}
         (H₂ : {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′) →⁽ᵉ⁾ A₂ (H₀ H₀′) (H₁ H₁′))
         {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′)
         →⁽ᵉ⁾ A₂ (H₀ H₀′) H₁′
       unequal head variables:
         _H
       does not equal
         _H
  
  [1]
  $ narya constants.ny -e "def cplus_one_two_eq_two : Id CN (cplus one two) two := refl two"
   ￫ error[E0401]
   ￭ command-line exec string
   1 | def cplus_one_two_eq_two : Id CN (cplus one two) two := refl two
     ^ term synthesized type
         {A₀ : Type} {A₁ : Type} (A₂ : refl Type A₀ A₁) {H₀ : A₀ → A₀} {H₁ : A₁ → A₁}
         (H₂ : {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′) →⁽ᵉ⁾ A₂ (H₀ H₀′) (H₁ H₁′))
         {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′)
         →⁽ᵉ⁾ A₂ (H₀ (H₀ H₀′)) (H₁ (H₁ H₁′))
       but is being checked against type
         {A₀ : Type} {A₁ : Type} (A₂ : refl Type A₀ A₁) {H₀ : A₀ → A₀} {H₁ : A₁ → A₁}
         (H₂ : {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′) →⁽ᵉ⁾ A₂ (H₀ H₀′) (H₁ H₁′))
         {H₀′ : A₀} {H₁′ : A₁} (H₂′ : A₂ H₀′ H₁′)
         →⁽ᵉ⁾ A₂ (H₀ (H₀ (H₀ H₀′))) (H₁ (H₁ H₁′))
       unequal head variables:
         _H
       does not equal
         _H
  
  [1]
  $ narya constants.ny -e "def ∞eta_bisim' : Id (Stream A → Stream A) (s ↦ s) (s ↦ ∞eta s) ≔ refl (s ↦ ∞eta s)"
   ￫ error[E0400]
   ￭ command-line exec string
   1 | def ∞eta_bisim' : Id (Stream A → Stream A) (s ↦ s) (s ↦ ∞eta s) ≔ refl (s ↦ ∞eta s)
     ^ non-synthesizing term in synthesizing position (argument of degeneracy)
  
  [1]
  $ narya constants.ny -e "def refl_nat_eq_sample : Id (ℕ → Id ((x:A)→B x) f f) (refl_nat_f) (refl_nat_f_cube) ≔ refl refl_nat_f"
   ￫ error[E0401]
   ￭ command-line exec string
   1 | def refl_nat_eq_sample : Id (ℕ → Id ((x:A)→B x) f f) (refl_nat_f) (refl_nat_f_cube) ≔ refl refl_nat_f
     ^ term synthesized type
         {H₀ : ℕ} {H₁ : ℕ} (H₂ : refl ℕ H₀ H₁)
         →⁽ᵉ⁾ Π⁽ᵉᵉ⁾ A⁽ᵉᵉ⁾ {x ↦ B x} {x ↦ B x} {x ⤇ refl B x.2} {x ↦ B x} {x ↦ B x}
                {x ⤇ refl B x.2} {x ⤇ refl B x.2} {x ⤇ refl B x.2} (x ⤇ B⁽ᵉᵉ⁾ x.22)
                (refl f) (refl f) (x ⤇ refl_nat_f H₀ x.2) (x ⤇ refl_nat_f H₁ x.2)
       but is being checked against type
         {H₀ : ℕ} {H₁ : ℕ} (H₂ : refl ℕ H₀ H₁)
         →⁽ᵉ⁾ Π⁽ᵉᵉ⁾ A⁽ᵉᵉ⁾ {x ↦ B x} {x ↦ B x} {x ⤇ refl B x.2} {x ↦ B x} {x ↦ B x}
                {x ⤇ refl B x.2} {x ⤇ refl B x.2} {x ⤇ refl B x.2} (x ⤇ B⁽ᵉᵉ⁾ x.22)
                (refl f) (refl f) (x ⤇ refl_nat_f H₀ x.2) (x ⤇ refl_nat_f_cube H₁ x.2)
       unequal head constants:
         refl_nat_f
       does not equal
         refl_nat_f_cube
  
  [1]
