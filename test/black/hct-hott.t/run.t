  $ rm -f *.nyo

  $ narya -v univalence.ny
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/isfibrant.ny
  
   ￫ info[I0000]
   ￮ constant isFibrant defined
  
   ￫ info[I0000]
   ￮ constant Fib defined
  
   ￫ info[I0000]
   ￮ constant Id𝕗 defined
  
   ￫ info[I0000]
   ￮ constant Idd𝕗 defined
  
   ￫ info[I0000]
   ￮ constant transport defined
  
   ￫ info[I0000]
   ￮ constant concat defined
  
   ￫ info[I0000]
   ￮ constant inverse defined
  
   ￫ info[I0000]
   ￮ constant transport2 defined
  
   ￫ info[I0000]
   ￮ constant refl_transport_1 defined
  
   ￫ info[I0000]
   ￮ constant refl_transport_2 defined
  
   ￫ info[I0000]
   ￮ constant Id𝕗2 defined
  
   ￫ info[I0000]
   ￮ constant concat_p1 defined
  
   ￫ info[I0000]
   ￮ constant J defined
  
   ￫ info[I0000]
   ￮ constant Sq𝕗 defined
  
   ￫ info[I0000]
   ￮ constant conn defined
  
   ￫ info[I0000]
   ￮ constant coconn defined
  
   ￫ info[I0000]
   ￮ constant concat_1p defined
  
   ￫ info[I0000]
   ￮ constant Jβ defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/isfibrant.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/bookhott.ny
  
   ￫ info[I0007]
   ￮ section eq opened
  
   ￫ info[I0000]
   ￮ constant eq defined
  
   ￫ info[I0000]
   ￮ constant cat defined
  
   ￫ info[I0000]
   ￮ constant cat3 defined
  
   ￫ info[I0000]
   ￮ constant idl defined
  
   ￫ info[I0000]
   ￮ constant inv defined
  
   ￫ info[I0000]
   ￮ constant ap defined
  
   ￫ info[I0000]
   ￮ constant ap_ap defined
  
   ￫ info[I0000]
   ￮ constant trr defined
  
   ￫ info[I0000]
   ￮ constant trr_ap defined
  
   ￫ info[I0000]
   ￮ constant trr2 defined
  
   ￫ info[I0000]
   ￮ constant trl2 defined
  
   ￫ info[I0000]
   ￮ constant trr2_ap defined
  
   ￫ info[I0000]
   ￮ constant whiskerR defined
  
   ￫ info[I0000]
   ￮ constant unwhiskerR defined
  
   ￫ info[I0008]
   ￮ section eq closed
  
   ￫ info[I0000]
   ￮ constant eq defined
  
   ￫ info[I0000]
   ￮ constant eqd defined
  
   ￫ info[I0000]
   ￮ constant ap2d defined
  
   ￫ info[I0000]
   ￮ constant eqdd defined
  
   ￫ info[I0000]
   ￮ constant ap3d defined
  
   ￫ info[I0007]
   ￮ section sq opened
  
   ￫ info[I0000]
   ￮ constant sq defined
  
   ￫ info[I0000]
   ￮ constant hrfl defined
  
   ￫ info[I0000]
   ￮ constant nat_toid defined
  
   ￫ info[I0000]
   ￮ constant ap defined
  
   ￫ info[I0000]
   ￮ constant act02 defined
  
   ￫ info[I0000]
   ￮ constant act20 defined
  
   ￫ info[I0000]
   ￮ constant to_cat defined
  
   ￫ info[I0000]
   ￮ constant to_cat3 defined
  
   ￫ info[I0000]
   ￮ constant all_rfl_21 defined
  
   ￫ info[I0000]
   ￮ constant unact21 defined
  
   ￫ info[I0000]
   ￮ constant cancel_12_eq_21 defined
  
   ￫ info[I0008]
   ￮ section sq closed
  
   ￫ info[I0000]
   ￮ constant sq defined
  
   ￫ info[I0000]
   ￮ constant selfnat defined
  
   ￫ info[I0000]
   ￮ constant eqv defined
  
   ￫ info[I0002]
   ￮ notation eqv defined
  
   ￫ info[I0000]
   ￮ constant fro_to_fro defined
  
   ￫ info[I0000]
   ￮ constant adjointify defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/bookhott.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/hott_bookhott.ny
  
   ￫ info[I0100]
   ￮ option set function boundaries to implicit
  
   ￫ info[I0100]
   ￮ option set type boundaries to implicit
  
   ￫ info[I0000]
   ￮ constant Id_eq defined
  
   ￫ info[I0000]
   ￮ constant Id_eqv defined
  
   ￫ info[I0000]
   ￮ constant 𝕗eqv defined
  
   ￫ info[I0000]
   ￮ constant sym_eqv defined
  
   ￫ info[I0000]
   ￮ constant 312_eqv defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/hott_bookhott.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/fibrant_types.ny
  
   ￫ info[I0100]
   ￮ option set function boundaries to implicit
  
   ￫ info[I0100]
   ￮ option set type boundaries to implicit
  
   ￫ info[I0000]
   ￮ constant ⊤ defined
  
   ￫ info[I0000]
   ￮ constant id_⊤_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗⊤ defined
  
   ￫ info[I0000]
   ￮ constant prod defined
  
   ￫ info[I0002]
   ￮ notation prod defined
  
   ￫ info[I0000]
   ￮ constant id_prod_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗prod defined
  
   ￫ info[I0000]
   ￮ constant Σ defined
  
   ￫ info[I0000]
   ￮ constant id_Σ_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Σ defined
  
   ￫ info[I0000]
   ￮ constant Σ𝕗 defined
  
   ￫ info[I0000]
   ￮ constant id_Π_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Π defined
  
   ￫ info[I0000]
   ￮ constant Π𝕗 defined
  
   ￫ info[I0000]
   ￮ constant ∅ defined
  
   ￫ info[I0000]
   ￮ constant 𝕗∅ defined
  
   ￫ info[I0000]
   ￮ constant Gel defined
  
   ￫ info[I0000]
   ￮ constant Gel_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Gel defined
  
   ￫ info[I0000]
   ￮ constant sum defined
  
   ￫ info[I0002]
   ￮ notation sum defined
  
   ￫ info[I0000]
   ￮ constant sum_code defined
  
   ￫ info[I0000]
   ￮ constant id_sum_iso defined
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   237 |       (match u0, u1 [
   238 |        | left. a0, left. a1 ↦ 𝕗A.2 .id a0 a1
   239 |        | left. _, right. _ ↦ 𝕗∅
   240 |        | right. _, left. _ ↦ 𝕗∅
   241 |        | right. b0, right. b1 ↦ 𝕗B.2 .id b0 b1]))]
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ info[I0000]
   ￮ constant 𝕗sum defined
  
   ￫ info[I0000]
   ￮ constant ℕ defined
  
   ￫ info[I0000]
   ￮ constant ℕ_code defined
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   256 |        match n0, n1 [
   257 |        | zero., zero. ↦ zero.
   258 |        | zero., suc. n1 ↦ match m2 [ ]
   259 |        | suc. n0, zero. ↦ match m2 [ ]
   260 |        | suc. n0, suc. n1 ↦ suc. (id_ℕ_iso n0 n1 .to m2)])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   261 |       ([ zero. ⤇ () | suc. m ⤇ id_ℕ_iso m.0 m.1 .fro m.2 ])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   263 |        match n0, n1 [
   264 |        | zero., zero. ↦ rfl.
   265 |        | zero., suc. n1 ↦ match m2 [ ]
   266 |        | suc. n0, zero. ↦ match m2 [ ]
   267 |        | suc. n0, suc. n1 ↦ id_ℕ_iso n0 n1 .fro_to m2])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   268 |       ([ zero. ⤇ rfl.
   269 |        | suc. m ⤇
   270 |            eq.ap (Id ℕ m.0 m.1) (Id ℕ (suc. m.0) (suc. m.1)) (x ↦ suc. x)
   271 |              (id_ℕ_iso m.0 m.1 .to (id_ℕ_iso m.0 m.1 .fro m.2)) m.2
   272 |              (id_ℕ_iso m.0 m.1 .to_fro m.2)])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ info[I0000]
   ￮ constant id_ℕ_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗_ℕ_code defined
  
   ￫ info[I0000]
   ￮ constant 𝕗ℕ defined
  
   ￫ info[I0001]
   ￮ axiom funext assumed
  
   ￫ info[I0000]
   ￮ constant funext_refl defined
  
   ￫ info[I0007]
   ￮ section Indexed_𝕎 opened
  
   ￫ info[I0000]
   ￮ constant 𝕎spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕎 defined
  
   ￫ info[I0000]
   ￮ constant code_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode_decode defined
  
   ￫ info[I0000]
   ￮ constant id_𝕎_iso defined
  
   ￫ info[I0008]
   ￮ section Indexed_𝕎 closed
  
   ￫ info[I0000]
   ￮ constant 𝕎 defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_code defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode_decode defined
  
   ￫ info[I0000]
   ￮ constant Id_𝕎_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗_𝕎_code defined
  
   ￫ info[I0000]
   ￮ constant 𝕗𝕎 defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕄 defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_code_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_decode defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_bisim defined
  
   ￫ info[I0001]
   ￮ axiom 𝕄_ext assumed
  
   ￫ info[I0000]
   ￮ constant 𝕄_encode_decode_bisim defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_encode_decode defined
  
   ￫ info[I0000]
   ￮ constant refl_𝕄_bisim defined
  
   ￫ info[I0001]
   ￮ axiom refl_𝕄_ext assumed
  
   ￫ info[I0000]
   ￮ constant 𝕄_decode_encode_bisim defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_decode_encode defined
  
   ￫ info[I0000]
   ￮ constant Id_𝕄_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗𝕄 defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/fibrant_types.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/homotopy.ny
  
   ￫ info[I0100]
   ￮ option set function boundaries to implicit
  
   ￫ info[I0100]
   ￮ option set type boundaries to implicit
  
   ￫ info[I0000]
   ￮ constant isContr defined
  
   ￫ info[I0000]
   ￮ constant iscontr_idfrom defined
  
   ￫ info[I0000]
   ￮ constant iscontr_idto defined
  
   ￫ info[I0000]
   ￮ constant is11 defined
  
   ￫ info[I0000]
   ￮ constant is11_Id defined
  
   ￫ info[I0000]
   ￮ constant isBisim defined
  
   ￫ info[I0000]
   ￮ constant bisim_of_11 defined
  
   ￫ info[I0000]
   ￮ constant isbisim_eqv defined
  
   ￫ info[I0000]
   ￮ constant bisim_of_Id defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/homotopy.ny (source)
  
   ￫ info[I0100]
   ￮ option set function boundaries to implicit
  
   ￫ info[I0100]
   ￮ option set type boundaries to implicit
  
   ￫ info[I0000]
   ￮ constant pre_univalence defined
  
   ￫ info[I0000]
   ￮ constant univalence_bisim defined
  
   ￫ info[I0000]
   ￮ constant univalence_11 defined
  
   ￫ info[I0000]
   ￮ constant is11_Id𝕗 defined
  
   ￫ info[I0000]
   ￮ constant srefl defined
  
   ￫ info[I0000]
   ￮ constant srefl_is_strict defined
  
   ￫ info[I0000]
   ￮ constant univalence_vv defined
  
   ￫ info[I0000]
   ￮ constant univalence_is_left_definitional defined
  
   ￫ info[I0000]
   ￮ constant univalence_is_right_definitional defined
  

  $ narya -v univalence_ee.ny
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/isfibrant.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/bookhott.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/hott_bookhott.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/fibrant_types.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/homotopy.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/univalence.ny (compiled)
  
   ￫ info[I0100]
   ￮ option set function boundaries to implicit
  
   ￫ info[I0100]
   ￮ option set type boundaries to implicit
  
   ￫ info[I0000]
   ￮ constant isBisim_ee defined
  
   ￫ info[I0000]
   ￮ constant isbisim_ee_eqv defined
  
   ￫ info[I0000]
   ￮ constant pre_univalence_ee defined
  
   ￫ info[I0000]
   ￮ constant Gel_ee defined
  
   ￫ info[I0000]
   ￮ constant Gel_ee_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Gel_ee defined
  
   ￫ info[I0000]
   ￮ constant univalence_ee defined
  
